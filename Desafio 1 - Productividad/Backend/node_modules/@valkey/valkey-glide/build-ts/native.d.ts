/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum Level {
    Debug = 3,
    Error = 0,
    Info = 2,
    Trace = 4,
    Warn = 1,
    Off = 5,
}
export const MAX_REQUEST_ARGS_LEN: number;
export const DEFAULT_REQUEST_TIMEOUT_IN_MILLISECONDS: number;
export const DEFAULT_CONNECTION_TIMEOUT_IN_MILLISECONDS: number;
export const DEFAULT_INFLIGHT_REQUESTS_LIMIT: number;
/**
 * Configuration for OpenTelemetry integration in the Node.js client.
 *
 * This struct allows you to configure how telemetry data (traces and metrics) is exported to an OpenTelemetry collector.
 * - `traces`: Optional configuration for exporting trace data. If `None`, trace data will not be exported.
 * - `metrics`: Optional configuration for exporting metrics data. If `None`, metrics data will not be exported.
 * - `flush_interval_ms`: Optional interval in milliseconds between consecutive exports of telemetry data. If `None`, a default value will be used.
 *
 * At least one of traces or metrics must be provided.
 */
export interface OpenTelemetryConfig {
    /** Optional configuration for exporting trace data. If `None`, trace data will not be exported. */
    traces?: OpenTelemetryTracesConfig;
    /** Optional configuration for exporting metrics data. If `None`, metrics data will not be exported. */
    metrics?: OpenTelemetryMetricsConfig;
    /** Optional interval in milliseconds between consecutive exports of telemetry data. If `None`, the default `DEFAULT_FLUSH_SIGNAL_INTERVAL_MS` will be used. */
    flushIntervalMs?: number;
}
/**
 * Configuration for exporting OpenTelemetry traces.
 *
 * - `endpoint`: The endpoint to which trace data will be exported. Expected format:
 *   - For gRPC: `grpc://host:port`
 *   - For HTTP: `http://host:port` or `https://host:port`
 *   - For file exporter: `file:///absolute/path/to/folder/file.json`
 * - `sample_percentage`: The percentage of requests to sample and create a span for, used to measure command duration. If `None`, a default value DEFAULT_TRACE_SAMPLE_PERCENTAGE will be used.
 *   Note: There is a tradeoff between sampling percentage and performance. Higher sampling percentages will provide more detailed telemetry data but will impact performance.
 *   It is recommended to keep this number low (1-5%) in production environments unless you have specific needs for higher sampling rates.
 */
export interface OpenTelemetryTracesConfig {
    /** The endpoint to which trace data will be exported. */
    endpoint: string;
    /**
     * The percentage of requests to sample and create a span for, used to measure command duration. If `None`, a default value DEFAULT_TRACE_SAMPLE_PERCENTAGE will be used.
     * Note: There is a tradeoff between sampling percentage and performance. Higher sampling percentages will provide more detailed telemetry data but will impact performance.
     * It is recommended to keep this number low (1-5%) in production environments unless you have specific needs for higher sampling rates.
     */
    samplePercentage?: number;
}
/**
 * Configuration for exporting OpenTelemetry metrics.
 *
 * - `endpoint`: The endpoint to which metrics data will be exported. Expected format:
 *   - For gRPC: `grpc://host:port`
 *   - For HTTP: `http://host:port` or `https://host:port`
 *   - For file exporter: `file:///absolute/path/to/folder/file.json`
 */
export interface OpenTelemetryMetricsConfig {
    /** The endpoint to which metrics data will be exported. */
    endpoint: string;
}
export declare function StartSocketConnection(): Promise<string>;
export declare function InitOpenTelemetry(
    openTelemetryConfig: OpenTelemetryConfig,
): void;
export declare function log(
    logLevel: Level,
    logIdentifier: string,
    message: string,
): void;
export declare function InitInternalLogger(
    level?: Level | undefined | null,
    fileName?: string | undefined | null,
): Level;
export declare function valueFromSplitPointer(
    highBits: number,
    lowBits: number,
    stringDecoder: boolean,
):
    | null
    | string
    | Uint8Array
    | number
    | {}
    | Boolean
    | BigInt
    | Set<any>
    | any[]
    | Buffer;
/**
 * @internal @test
 * This function is for tests that require a value allocated on the heap.
 * Should NOT be used in production.
 */
export declare function createLeakedStringVec(
    message: Array<Uint8Array>,
): [number, number];
/** Creates an open telemetry span with the given name and returns a pointer to the span */
export declare function createLeakedOtelSpan(name: string): [number, number];
export declare function dropOtelSpan(spanPtr: bigint): void;
export declare function getStatistics(): object;
export declare class AsyncClient {
    static CreateConnection(connectionAddress: string): AsyncClient;
    get(key: string): Promise<string | Buffer | null>;
    set(key: string, value: string): Promise<string | Buffer | "OK" | null>;
}
/** A wrapper for a script object. As long as this object is alive, the script's code is saved in memory, and can be resent to the server. */
export declare class Script {
    /** Construct with the script's code. */
    constructor(code: string | Uint8Array);
    /** Returns the hash of the script. */
    getHash(): string;
    /**
     * Decrements the script's reference count in the local container.
     * Removes the script when the count reaches zero.
     *
     * This method is primarily intended for testing or manual cleanup.
     * It does not need to be called explicitly, as the script will be automatically
     * released when dropped.
     */
    release(): void;
}
/**
 * This struct is used to keep track of the cursor of a cluster scan.
 * We want to avoid passing the cursor between layers of the application,
 * So we keep the state in the container and only pass the id of the cursor.
 * The cursor is stored in the container and can be retrieved using the id.
 * The cursor is removed from the container when the object is deleted (dropped).
 * To create a cursor:
 * ```typescript
 * // For a new cursor
 * let cursor = new ClusterScanCursor();
 * // Using an existing id
 * let cursor = new ClusterScanCursor("cursor_id");
 * ```
 * To get the cursor id:
 * ```typescript
 * let cursorId = cursor.getCursor();
 * ```
 * To check if the scan is finished:
 * ```typescript
 * let isFinished = cursor.isFinished(); // true if the scan is finished
 * ```
 */
export declare class ClusterScanCursor {
    constructor(newCursor?: string | undefined | null);
    /** Returns the cursor id. */
    getCursor(): string;
    /** Returns true if the scan is finished. */
    isFinished(): boolean;
}
