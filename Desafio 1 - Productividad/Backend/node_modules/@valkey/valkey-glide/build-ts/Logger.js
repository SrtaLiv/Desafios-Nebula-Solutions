"use strict";
/**
 * Copyright Valkey GLIDE Project Contributors - SPDX Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = void 0;
const _1 = require(".");
const LEVEL = new Map([
    ["error", 0 /* Level.Error */],
    ["warn", 1 /* Level.Warn */],
    ["info", 2 /* Level.Info */],
    ["debug", 3 /* Level.Debug */],
    ["trace", 4 /* Level.Trace */],
    ["off", 5 /* Level.Off */],
    [undefined, undefined],
]);
/**
 * A singleton class that allows logging which is consistent with logs from the internal GLIDE core.
 * The logger can be set up in 2 ways -
 *   1. By calling {@link init}, which configures the logger only if it wasn't previously configured.
 *   2. By calling {@link setLoggerConfig}, which replaces the existing configuration, and means that new logs
 *     will not be saved with the logs that were sent before the call. The previous logs will remain unchanged.
 * If none of these functions are called, the first log attempt will initialize a new logger with default configuration.
 */
class Logger {
    static _instance;
    static logger_level = 0;
    constructor(level, fileName) {
        Logger.logger_level = (0, _1.InitInternalLogger)(LEVEL.get(level), fileName);
    }
    /**
     * Logs the provided message if the provided log level is lower then the logger level.
     *
     * @param logLevel - The log level of the provided message.
     * @param logIdentifier - The log identifier should give the log a context.
     * @param message - The message to log.
     * @param err - The exception or error to log.
     */
    static log(logLevel, logIdentifier, message, err) {
        if (!Logger._instance) {
            new Logger();
        }
        if (err) {
            message += `: ${err.stack}`;
        }
        const level = LEVEL.get(logLevel) || 0;
        if (!(level <= Logger.logger_level))
            return;
        (0, _1.log)(level, logIdentifier, message);
    }
    /**
     * Initialize a logger if it wasn't initialized before - this method is meant to be used when there is no intention to
     * replace an existing logger.
     * The logger will filter all logs with a level lower than the given level.
     * If given a fileName argument, will write the logs to files postfixed with fileName. If fileName isn't provided,
     * the logs will be written to the console.
     *
     * @param level - Set the logger level to one of [ERROR, WARN, INFO, DEBUG, TRACE, OFF].
     *   If log level isn't provided, the logger will be configured with default configuration.
     *   To turn off logging completely, set the level to level "off".
     * @param fileName - If provided the target of the logs will be the file mentioned.
     *   Otherwise, logs will be printed to the console.
     */
    static init(level, fileName) {
        if (!this._instance) {
            this._instance = new this(level, fileName);
        }
    }
    /**
     * Creates a new logger instance and configure it with the provided log level and file name.
     *
     * @param level - Set the logger level to one of [ERROR, WARN, INFO, DEBUG, TRACE, OFF].
     * @param fileName - The target of the logs will be the file mentioned.
     */
    static setLoggerConfig(level, fileName) {
        this._instance = new this(level, fileName);
    }
}
exports.Logger = Logger;
